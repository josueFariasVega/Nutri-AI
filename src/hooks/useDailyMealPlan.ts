import { useState, useCallback, useEffect, useMemo, useRef } from 'react';
import { supabase } from '../lib/utils/supabase/client';
import { fetchEdge } from '../lib/utils/supabase/edge';
import { Coffee, Apple, Utensils, Moon } from 'lucide-react';
import { useLoadingNotifications } from '../components/ui/notifications';
import { logger } from '../lib/utils/logger';
import { useMealPlanWithAPI } from './useMealPlanWithAPI';


// Tipos
interface FoodItem {
  id: string;
  name: string;
  calories: number;
  protein: number;
  carbs: number;
  fat: number;
  consumed: boolean;
}

interface DailyMeal {
  id: string;
  time: string;
  meal: string;
  icon: any;
  calories: number;
  targetCalories: number;
  items: FoodItem[];
  completed: boolean;
}

interface NutritionPlan {
  meals: {
    breakfast?: { foods: any[]; targetCalories: number };
    lunch?: { foods: any[]; targetCalories: number };
    dinner?: { foods: any[]; targetCalories: number };
    snacks?: { foods: any[]; targetCalories: number };
  };
  macros: {
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
  };
  currentWeight?: number;
}

interface DailyPlanData {
  date: string;
  plan: NutritionPlan;
  dailyMeals: DailyMeal[];
  completedMeals: string[];
  consumedItems: string[];
  lastUpdated: string;
  autoGenerated: boolean;
  hydration: {
    target: number;
    consumed: number;
    glasses: number;
  };
  metrics: {
    weight: number;
    energy: number;
    sleep: number;
    steps: number;
  };
}

interface DailyHistoricalRecord {
  date: string;
  caloriesConsumed: number;
  caloriesTarget: number;
  macrosConsumed: {
    protein: number;
    carbs: number;
    fat: number;
  };
  macrosTarget: {
    protein: number;
    carbs: number;
    fat: number;
  };
  mealsCompleted: string[];
  totalMeals: number;
  hydration: {
    glasses: number;
    consumed: number;
    target: number;
  };
  metrics: {
    weight?: number;
    energy?: number;
    sleep?: number;
    steps?: number;
  };
  completionRate: number;
  lastUpdated: string;
}

interface HistoricalData {
  [date: string]: DailyHistoricalRecord;
}

interface HistoricalStats {
  averageCalories: number;
  averageCompletionRate: number;
  totalDays: number;
  bestDay: string;
  worstDay: string;
  trends: {
    calories: 'increasing' | 'decreasing' | 'stable';
    weight: 'increasing' | 'decreasing' | 'stable';
    completion: 'increasing' | 'decreasing' | 'stable';
  };
}




export function useDailyMealPlan() {
  const [dailyPlan, setDailyPlan] = useState<DailyPlanData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [lastPlanGeneration, setLastPlanGeneration] = useState<Date | null>(null);
  const { convertNutritionPlanToMealsWithAPI } = useMealPlanWithAPI();
  
  const hasInitialized = useRef(false);

  const DAILY_PLAN_KEY = 'daily_meal_plan';
  const LAST_GENERATION_KEY = 'last_plan_generation';
  const HISTORICAL_DATA_KEY = 'nutrition_historical_data';

  // ‚úÖ REFERENCIAS PARA ACCEDER A FUNCIONES DESDE CALLBACKS AS√çNCRONOS
  const checkAndResetDailyPlanRef = useRef<(() => Promise<void>) | null>(null);
  const generateDailyPlanRef = useRef<(preserveCompletedMeals?: boolean) => Promise<void>>();
  const saveHistoricalDataRef = useRef<((planData: DailyPlanData) => void) | null>(null);
  const showDayChangeNotificationRef = useRef<() => void>();
  const setDailyPlanRef = useRef<(plan: DailyPlanData | null) => void>();
  const setLoadingRef = useRef<((loading: boolean) => void) | null>(null);
  const dailyPlanRef = useRef<DailyPlanData | null>(null);

  // Actualizar referencia del estado
  useEffect(() => {
    dailyPlanRef.current = dailyPlan;
  }, [dailyPlan]);
  
  const {
    showPlanRegenerationNotification,
    showPlanGeneratedNotification,
    showDayChangeNotification,
    showHydrationReminder,
    showMealCompletionNotification,
  } = useLoadingNotifications();

  const calculateConsumedNutrition = useCallback((dailyPlan: DailyPlanData) => {
    const consumedItems = dailyPlan.dailyMeals.reduce(
      (acc, meal) => acc.concat(meal.items.filter(item => item.consumed)), 
      []
    );
    
    return {
      calories: consumedItems.reduce((sum, item) => sum + item.calories, 0),
      protein: consumedItems.reduce((sum, item) => sum + item.protein, 0),
      carbs: consumedItems.reduce((sum, item) => sum + item.carbs, 0),
      fat: consumedItems.reduce((sum, item) => sum + item.fat, 0),
    };
  }, []);

  const calculateCompletionRate = useCallback((dailyPlan: DailyPlanData): number => {
    const totalMeals = dailyPlan.dailyMeals.length;
    const completedMeals = dailyPlan.dailyMeals.filter(meal => meal.completed).length;
    return totalMeals > 0 ? (completedMeals / totalMeals) * 100 : 0;
  }, []);

  const saveHistoricalData = useCallback((planData: DailyPlanData): void => {
    try {
      const existingHistory = localStorage.getItem(HISTORICAL_DATA_KEY);
      const history: HistoricalData = existingHistory ? JSON.parse(existingHistory) : {};

      const consumedItems = planData.dailyMeals.reduce((acc, meal) => 
        acc.concat(meal.items.filter(item => item.consumed)), []
      );

      const caloriesConsumed = consumedItems.reduce((sum, item) => sum + item.calories, 0);
      const proteinConsumed = consumedItems.reduce((sum, item) => sum + item.protein, 0);
      const carbsConsumed = consumedItems.reduce((sum, item) => sum + item.carbs, 0);
      const fatConsumed = consumedItems.reduce((sum, item) => sum + item.fat, 0);

      const completedMeals = planData.dailyMeals.filter(meal => meal.completed).map(meal => meal.id);
      const completionRate = (completedMeals.length / planData.dailyMeals.length) * 100;

      const historicalRecord: DailyHistoricalRecord = {
        date: planData.date,
        caloriesConsumed,
        caloriesTarget: planData.plan.macros.calories,
        macrosConsumed: {
          protein: Math.round(proteinConsumed),
          carbs: Math.round(carbsConsumed),
          fat: Math.round(fatConsumed)
        },
        macrosTarget: {
          protein: planData.plan.macros.protein,
          carbs: planData.plan.macros.carbs,
          fat: planData.plan.macros.fat
        },
        mealsCompleted: completedMeals,
        totalMeals: planData.dailyMeals.length,
        hydration: planData.hydration,
        metrics: planData.metrics,
        completionRate,
        lastUpdated: new Date().toISOString()
      };

      history[planData.date] = historicalRecord;
      localStorage.setItem(HISTORICAL_DATA_KEY, JSON.stringify(history));
      
      logger.log(`üìä Datos hist√≥ricos guardados para ${planData.date}:`, historicalRecord);
    } catch (error) {
      logger.error('Error saving historical data:', error);
    }
  }, []);

  // ‚úÖ Actualizar referencia
  saveHistoricalDataRef.current = saveHistoricalData;
  const getHistoricalData = useCallback((): HistoricalData => {
    try {
      const stored = localStorage.getItem(HISTORICAL_DATA_KEY);
      return stored ? JSON.parse(stored) : {};
    } catch (error) {
      logger.error('Error loading historical data:', error);
      return {};
    }
  }, []);

  const calculateHistoricalStats = useCallback((days: number = 30): HistoricalStats | null => {
    const history = getHistoricalData();
    const records = Object.values(history);

    if (records.length === 0) return null;

    const totalCalories = records.reduce((sum, record) => sum + record.caloriesConsumed, 0);
    const totalCompletionRate = records.reduce((sum, record) => sum + record.completionRate, 0);

    const bestDay = records.reduce((best, current) => 
      current.completionRate > best.completionRate ? current : best
    );

    const worstDay = records.reduce((worst, current) => 
      current.completionRate < worst.completionRate ? current : worst
    );

    const recentRecords = records.slice(-7);
    const olderRecords = records.slice(-14, -7);

    const calculateTrend = (recent: number[], older: number[]): 'increasing' | 'decreasing' | 'stable' => {
      if (recent.length === 0 || older.length === 0) return 'stable';
      
      const recentAvg = recent.reduce((sum, val) => sum + val, 0) / recent.length;
      const olderAvg = older.reduce((sum, val) => sum + val, 0) / older.length;
      
      const diff = ((recentAvg - olderAvg) / olderAvg) * 100;
      
      if (diff > 5) return 'increasing';
      if (diff < -5) return 'decreasing';
      return 'stable';
    };

    return {
      averageCalories: Math.round(totalCalories / records.length),
      averageCompletionRate: Math.round(totalCompletionRate / records.length),
      totalDays: records.length,
      bestDay: bestDay.date,
      worstDay: worstDay.date,
      trends: {
        calories: calculateTrend(
          recentRecords.map(r => r.caloriesConsumed),
          olderRecords.map(r => r.caloriesConsumed)
        ),
        weight: calculateTrend(
          recentRecords.map(r => r.metrics.weight || 0).filter(w => w > 0),
          olderRecords.map(r => r.metrics.weight || 0).filter(w => w > 0)
        ),
        completion: calculateTrend(
          recentRecords.map(r => r.completionRate),
          olderRecords.map(r => r.completionRate)
        ),
      },
    };
  }, [getHistoricalData]);

  const getCurrentDate = (): string => {
    return new Date().toISOString().split('T')[0];
  };

  const generateItemId = (mealType: string, itemName: string, index: number): string => {
    return `${mealType}_${itemName.toLowerCase().replace(/\s+/g, '_')}_${index}`;
  };

  const convertNutritionPlanToMeals = useCallback((plan: NutritionPlan, completedMeals: string[] = []): DailyMeal[] => {
    const mealTimes = {
      breakfast: '07:00',
      'morning-snack': '10:30',
      lunch: '13:30',
      'afternoon-snack': '16:00',
      dinner: '20:00'
    };

    const meals: DailyMeal[] = [];

    const addRealVarietyToFoods = (foods: any[], mealType: string) => {
      if (!foods || foods.length === 0) return foods;
      
      const today = new Date();
      const dayOfWeek = today.getDay();
      
      const foodVariationsByMeal = {
        breakfast: {
          0: ['Tortilla espa√±ola con espinacas', 'Tostada integral con aguacate', 'Yogurt griego con granola'],
          1: ['Avena con frutas del bosque', 'Huevo revuelto con champi√±ones', 'Smoothie verde detox'],
          2: ['Pancakes de avena', 'Tostada con queso fresco', 'Batido de prote√≠nas'],
          3: ['Cereal integral con leche', 'Croissant integral', 'Caf√© con leche'],
          4: ['Bowl de a√ßa√≠', 'Pan de centeno tostado', 'Infusi√≥n de hierbas'],
          5: ['Muesli casero', 'Bagel integral', 'T√© verde matcha'],
          6: ['French toast saludable', 'Yogurt con miel', 'Zumo natural naranja']
        },
        lunch: {
          0: ['Ensalada C√©sar con pollo', 'Arroz integral con verduras', 'Sopa de lentejas'],
          1: ['Pasta integral con pesto', 'Salm√≥n a la plancha', 'Gazpacho andaluz'],
          2: ['Quinoa con vegetales', 'Pechuga de pavo', 'Crema de calabaza'],
          3: ['Risotto de champi√±ones', 'Merluza al horno', 'Ensalada mixta'],
          4: ['Tacos de pescado', 'Pollo al curry', 'Sopa miso'],
          5: ['Bowl mediterr√°neo', 'At√∫n sellado', 'Vichyssoise'],
          6: ['Paella de verduras', 'Lubina a la sal', 'Consom√© de pollo']
        },
        dinner: {
          0: ['Salm√≥n con esp√°rragos', 'Pur√© de coliflor', 'Infusi√≥n digestiva'],
          1: ['Pechuga pollo hierbas', 'Verduras al vapor', 'T√© relajante'],
          2: ['Pescado blanco plancha', 'Ensalada verde', 'Manzanilla'],
          3: ['Tofu salteado', 'Br√≥coli al vapor', 'T√© de jengibre'],
          4: ['Sepia a la plancha', 'Calabac√≠n relleno', 'Tila natural'],
          5: ['Pollo al lim√≥n', 'Jud√≠as verdes', 'Valeriana'],
          6: ['Dorada al horno', 'Espinacas salteadas', 'Melisa']
        },
        snacks: {
          0: ['Almendras naturales', 'Manzana verde', 'Yogurt desnatado'],
          1: ['Nueces con pasas', 'Pera conferencia', 'Queso fresco'],
          2: ['Pistachos sin sal', 'Pl√°tano maduro', 'Hummus casero'],
          3: ['Anacardos tostados', 'Kiwi dorado', 'Reques√≥n'],
          4: ['Mix frutos secos', 'Naranja navel', 'Cottage cheese'],
          5: ['Avellanas crudas', 'Uvas rojas', 'Yogurt griego'],
          6: ['Semillas calabaza', 'Melocot√≥n', 'Ricotta light']
        }
      };
      
      const mealVariations = foodVariationsByMeal[mealType] || foodVariationsByMeal.snacks;
      const dayVariations = mealVariations[dayOfWeek] || mealVariations[0];
      
      return foods.map((food, index) => {
        const newFoodName = dayVariations[index % dayVariations.length];
        const calorieVariation = Math.random() * 0.3 - 0.15;
        const newCalories = Math.max(30, Math.round(food.calories * (1 + calorieVariation)));
        
        return {
          ...food,
          name: newFoodName,
          calories: newCalories,
          protein: Math.max(1, Math.round(food.protein * (1 + calorieVariation * 0.5))),
          carbs: Math.max(1, Math.round(food.carbs * (1 + calorieVariation * 0.5))),
          fat: Math.max(1, Math.round(food.fat * (1 + calorieVariation * 0.5)))
        };
      });
    };

    // Desayuno
    if (plan.meals.breakfast?.foods?.length > 0) {
      const variedFoods = addRealVarietyToFoods(plan.meals.breakfast.foods, 'breakfast');
      meals.push({
        id: 'breakfast',
        time: mealTimes.breakfast,
        meal: 'Desayuno',
        icon: Coffee,
        calories: plan.meals.breakfast.targetCalories,
        targetCalories: plan.meals.breakfast.targetCalories,
        items: variedFoods.map((item, index) => ({ 
          id: generateItemId('breakfast', item.name, index), 
          ...item, 
          consumed: false 
        })),
        completed: completedMeals.includes('breakfast')
      });
    }

    // Media ma√±ana
    if (plan.meals.snacks?.foods?.length > 0) {
      const morningSnack = addRealVarietyToFoods([plan.meals.snacks.foods[0]], 'snacks')[0];
      if (morningSnack) {
        meals.push({
          id: 'morning-snack',
          time: mealTimes['morning-snack'],
          meal: 'Media Ma√±ana',
          icon: Apple,
          calories: Math.round(plan.meals.snacks.targetCalories * 0.4),
          targetCalories: Math.round(plan.meals.snacks.targetCalories * 0.4),
          items: [{ 
            id: generateItemId('morning-snack', morningSnack.name, 0), 
            ...morningSnack, 
            consumed: false 
          }],
          completed: completedMeals.includes('morning-snack')
        });
      }
    }

    // Almuerzo
    if (plan.meals.lunch?.foods?.length > 0) {
      const variedFoods = addRealVarietyToFoods(plan.meals.lunch.foods, 'lunch');
      meals.push({
        id: 'lunch',
        time: mealTimes.lunch,
        meal: 'Almuerzo',
        icon: Utensils,
        calories: plan.meals.lunch.targetCalories,
        targetCalories: plan.meals.lunch.targetCalories,
        items: variedFoods.map((item, index) => ({ 
          id: generateItemId('lunch', item.name, index), 
          ...item, 
          consumed: false 
        })),
        completed: completedMeals.includes('lunch')
      });
    }

    // Merienda
    if (plan.meals.snacks?.foods?.length > 1) {
      const afternoonSnack = addRealVarietyToFoods([plan.meals.snacks.foods[1]], 'snacks')[0];
      if (afternoonSnack) {
        meals.push({
          id: 'afternoon-snack',
          time: mealTimes['afternoon-snack'],
          meal: 'Merienda',
          icon: Apple,
          calories: Math.round(plan.meals.snacks.targetCalories * 0.6),
          targetCalories: Math.round(plan.meals.snacks.targetCalories * 0.6),
          items: [{ 
            id: generateItemId('afternoon-snack', afternoonSnack.name, 0), 
            ...afternoonSnack, 
            consumed: false 
          }],
          completed: completedMeals.includes('afternoon-snack')
        });
      }
    }

    // Cena
    if (plan.meals.dinner?.foods?.length > 0) {
      const variedFoods = addRealVarietyToFoods(plan.meals.dinner.foods, 'dinner');
      meals.push({
        id: 'dinner',
        time: mealTimes.dinner,
        meal: 'Cena',
        icon: Moon,
        calories: plan.meals.dinner.targetCalories,
        targetCalories: plan.meals.dinner.targetCalories,
        items: variedFoods.map((item, index) => ({ 
          id: generateItemId('dinner', item.name, index), 
          ...item, 
          consumed: false 
        })),
        completed: completedMeals.includes('dinner')
      });
    }

    return meals;
  }, []);

  const fetchNutritionPlan = useCallback(async (): Promise<NutritionPlan | null> => {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      if (!session) {
        throw new Error('No hay sesi√≥n activa');
      }

      const response = await fetchEdge('nutrition-plan', {
        headers: {
          'Authorization': `Bearer ${session.access_token}`,
        },
      });

      if (response.ok) {
        const data = await response.json();
        return data.plan || data;
      } else if (response.status === 404) {
        return null;
      } else {
        throw new Error(`Error ${response.status}: ${await response.text()}`);
      }
    } catch (error) {
      logger.error('Error fetching nutrition plan:', error);
      throw error;
    }
  }, []);
  const generateDailyPlan = useCallback(async (preserveCompletedMeals: boolean = true): Promise<void> => {
    setLoading(true);
    setError(null);

    try {
      let existingCompletedMeals: string[] = [];
      if (preserveCompletedMeals && dailyPlan) {
        existingCompletedMeals = dailyPlan.completedMeals;
      }

      const nutritionPlan = await fetchNutritionPlan();
      
      if (!nutritionPlan) {
        setError('No se encontr√≥ un plan nutricional. Por favor, completa el cuestionario primero.');
        setLoading(false);
        return;
      }

      const dailyMeals = await convertNutritionPlanToMealsWithAPI(nutritionPlan, existingCompletedMeals)
        .catch(error => {
          logger.warn('API fall√≥, usando m√©todo tradicional:', error);
          return convertNutritionPlanToMeals(nutritionPlan, existingCompletedMeals);
        });

      const newDailyPlan: DailyPlanData = {
        date: getCurrentDate(),
        plan: nutritionPlan,
        dailyMeals: dailyMeals,
        completedMeals: existingCompletedMeals,
        consumedItems: [],
        lastUpdated: new Date().toISOString(),
        autoGenerated: true,
        hydration: {
          target: 2000,
          consumed: 0,
          glasses: 0
        },
        metrics: {
          weight: nutritionPlan.currentWeight || 0,
          energy: 8,
          sleep: 7,
          steps: 0
        }
      };

      try {
        localStorage.setItem(DAILY_PLAN_KEY, JSON.stringify(newDailyPlan));
        localStorage.setItem(LAST_GENERATION_KEY, new Date().toISOString());
      } catch (error) {
        logger.error('Error storing plan:', error);
      }
      
      setDailyPlan(newDailyPlan);
      setLastPlanGeneration(new Date());
      showPlanGeneratedNotification();

    } catch (error) {
      logger.error('Error generating daily plan:', error);
      setError(error instanceof Error ? error.message : 'Error generando el plan diario');
    } finally {
      setLoading(false);
    }
  }, [fetchNutritionPlan, convertNutritionPlanToMeals, dailyPlan, showPlanGeneratedNotification]);

  // ‚úÖ Actualizar referencias
  generateDailyPlanRef.current = generateDailyPlan;
  setDailyPlanRef.current = setDailyPlan;
  setLoadingRef.current = setLoading;
  showDayChangeNotificationRef.current = showDayChangeNotification;

  
  const resetDailyPlanState = useCallback(() => {
    setDailyPlan(prev => {
      if (!prev) return prev;
  
      const clearedPlan: DailyPlanData = {
        ...prev,
        dailyMeals: prev.dailyMeals.map(meal => ({
          ...meal,
          completed: false,
          items: meal.items.map(item => ({ ...item, consumed: false }))
        })),
        completedMeals: [],
        consumedItems: [],
        hydration: {
          ...prev.hydration,
          glasses: 0,
          consumed: 0
        },
        metrics: {
          ...prev.metrics,
          energy: 8,
          sleep: 7,
          steps: 0
        },
        lastUpdated: new Date().toISOString()
      };
  
      localStorage.setItem(DAILY_PLAN_KEY, JSON.stringify(clearedPlan));
      return clearedPlan;
    });
  }, []);

  // ‚úÖ AGREGAR AQU√ç (ANTES de checkAndResetDailyPlan l√≠nea 606)
const handleServiceWorkerReset = useCallback(async (data: any) => {
  try {
    logger.log('üåÖ Service Worker solicita reset diario:', data);
    
    const currentDate = getCurrentDate();
    const stored = localStorage.getItem(DAILY_PLAN_KEY);
    
    if (stored && saveHistoricalDataRef.current) {
      const planData: DailyPlanData = JSON.parse(stored);
      if (planData.date !== currentDate) {
        logger.log('üíæ Guardando datos hist√≥ricos desde Service Worker...');
        saveHistoricalDataRef.current(planData);
        
        // Limpiar y regenerar
        localStorage.removeItem(DAILY_PLAN_KEY);
        localStorage.removeItem(LAST_GENERATION_KEY);
        
        if (generateDailyPlanRef.current) {
          await generateDailyPlanRef.current(false);
        }
        
        logger.log('‚úÖ Reset diario completado desde Service Worker');
      } else {
        logger.log('üìã Plan ya actual desde Service Worker');
      }
    }
  } catch (error) {
    logger.error('‚ùå Error en reset desde Service Worker:', error);
  }
}, []);


 // ‚úÖ FUNCI√ìN CR√çTICA: checkAndResetDailyPlan
const checkAndResetDailyPlan = useCallback(async (): Promise<void> => {
  try {
    const currentDate = getCurrentDate();
    const storedPlan = localStorage.getItem(DAILY_PLAN_KEY);
    
    if (!storedPlan) {
      logger.log('üìã No hay plan almacenado, generando nuevo plan');
      await generateDailyPlan();
      return;
    }
    
    const planData: DailyPlanData = JSON.parse(storedPlan);
    
    // ‚úÖ Si la fecha del plan es diferente a hoy ‚Üí HACER RESET
    if (planData.date !== currentDate) {
      logger.log(`üîÑ Cambio de d√≠a detectado: ${planData.date} ‚Üí ${currentDate}`);
      
      // 1. üìä GUARDAR DATOS DEL D√çA ANTERIOR COMO HIST√ìRICOS
      if (saveHistoricalDataRef.current) {
        await saveHistoricalDataRef.current(planData);
      }
      
      // 2. üóëÔ∏è LIMPIAR DATOS DEL D√çA ANTERIOR
      localStorage.removeItem(DAILY_PLAN_KEY);
      
      // 3. üÜï GENERAR NUEVO PLAN PARA HOY
      await generateDailyPlan();
      
      logger.log(`‚úÖ Reset diario completado: ${planData.date} ‚Üí ${currentDate}`);
    } else {
      logger.log(`üìã Plan del d√≠a actual ya existe: ${currentDate}`);
      
      // Restaurar plan desde localStorage
      setDailyPlan(planData);
      if (setLoadingRef.current) {
        setLoadingRef.current(false);
      }
    }
  } catch (error) {
    logger.error('‚ùå Error en checkAndResetDailyPlan:', error);
    // Fallback: generar nuevo plan
    await generateDailyPlan();
  }
}, [generateDailyPlan]);

window.testHook = { checkAndResetDailyPlan };

checkAndResetDailyPlanRef.current = checkAndResetDailyPlan;
saveHistoricalDataRef.current = saveHistoricalData;

  const setupPeriodicCheck = useCallback((): (() => void) => {
    const checkInterval = setInterval(async () => {
      const currentDate = getCurrentDate();
      const currentPlan = dailyPlanRef.current;
      if (currentPlan && currentPlan.date !== currentDate) {
        logger.log(`üîÑ Cambio de d√≠a detectado: ${currentPlan.date} ‚Üí ${currentDate}`);
        if (checkAndResetDailyPlanRef.current) {
          await checkAndResetDailyPlanRef.current();
        }
      }
    }, 30 * 1000);
    
    return () => clearInterval(checkInterval);
  }, []);

  const setupServiceWorker = useCallback((): (() => void) => {
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/sw.js', {
        scope: '/',
        updateViaCache: 'none'
      }).then((registration) => {
        logger.log('‚úÖ Service Worker registrado:', registration.scope);
        
        const onMessage = (event: MessageEvent) => {
          const { type, data } = event.data || {};
          
          switch (type) {
            case 'DAILY_RESET_REQUESTED':
              logger.log('üåÖ Service Worker solicita reset diario:', data);
              window.dispatchEvent(new CustomEvent('dailyResetRequested', { 
                detail: data 
              }));
              break;
              
            case 'DAILY_RESET_ERROR':
              logger.error('‚ùå Service Worker reporta error en reset:', data);
              break;
              
            case 'STATUS_RESPONSE':
              logger.log('üìä Service Worker status:', data);
              break;
              
            default:
              logger.log('üì® Service Worker mensaje:', type, data);
          }
        };
        
        navigator.serviceWorker.addEventListener('message', onMessage);
        
        return () => {
          navigator.serviceWorker.removeEventListener('message', onMessage);
        };
      }).catch((error) => {
        logger.error('‚ùå Error registrando Service Worker:', error);
      });
    } else {
      logger.warn('‚ö†Ô∏è Service Workers no soportados en este navegador');
    }
    
    return () => {};
  }, []);

  const setupFallbackReset = useCallback((): (() => void) => {
    const now = new Date();
    const tomorrow = new Date(now);
    tomorrow.setDate(tomorrow.getDate() + 1);
    tomorrow.setHours(0, 0, 0, 0);

    const timeUntilUpdate = tomorrow.getTime() - now.getTime();
    
    logger.log(`‚è∞ Fallback: Reset programado en ${Math.round(timeUntilUpdate / 1000 / 60)} minutos`);

    const timeoutId = setTimeout(async () => {
      logger.log('üåÖ Ejecutando reset autom√°tico (fallback)');
      await handleServiceWorkerReset({ source: 'fallback_timeout' });
    }, timeUntilUpdate);
    
    return () => clearTimeout(timeoutId);
  }, [handleServiceWorkerReset]);

  const handleVisibilityChange = useCallback(async () => {
    if (!document.hidden) {
      const currentDate = getCurrentDate();
      const currentPlan = dailyPlanRef.current;
      if (currentPlan && currentPlan.date !== currentDate) {
        if (checkAndResetDailyPlanRef.current) {
          await checkAndResetDailyPlanRef.current();
        }
      }
    }
  }, []);
  
  const handleFocus = useCallback(async () => {
    const currentDate = getCurrentDate();
    const currentPlan = dailyPlanRef.current;
    if (currentPlan && currentPlan.date !== currentDate) {
      if (checkAndResetDailyPlanRef.current) {
        await checkAndResetDailyPlanRef.current();
      }
    }
  }, []);

/**
 * Inicializaci√≥n del hook
 */
useEffect(() => {
  if (hasInitialized.current) return;
  
  const initializePlan = async () => {
    if (setLoadingRef.current) {
      setLoadingRef.current(true);
    }
    if (checkAndResetDailyPlanRef.current) {
      await checkAndResetDailyPlanRef.current();
    }

    // Configurar Service Worker
    const swCleanup = setupServiceWorker();
    
    // Configurar fallback de reset
    const fallbackCleanup = setupFallbackReset();
    
    // ‚úÖ Listener para eventos del Service Worker (evita problemas de hooks)
    const handleDailyResetEvent = async (event: CustomEvent) => {
      if (handleServiceWorkerReset) {
        await handleServiceWorkerReset(event.detail);
      }
    };
    
    window.addEventListener('dailyResetRequested', handleDailyResetEvent as EventListener);
    
    // ‚ùå REMOVER estas l√≠neas:
    // const handleVisibilityChange = async () => { ... };
    // const handleFocus = async () => { ... };
    
    document.addEventListener('visibilitychange', handleVisibilityChange);
    window.addEventListener('focus', handleFocus);
    
    return () => {
      swCleanup();
      fallbackCleanup();
      document.removeEventListener('visibilitychange', handleVisibilityChange);
      window.removeEventListener('focus', handleFocus);
      window.removeEventListener('dailyResetRequested', handleDailyResetEvent as EventListener);
    };
  };

  initializePlan();
  hasInitialized.current = true;

}, [setupServiceWorker, setupFallbackReset, handleServiceWorkerReset, handleVisibilityChange, handleFocus]); // ‚úÖ Agregar las dependencias

/**
 * Verificaci√≥n peri√≥dica del cambio de d√≠a
 */
useEffect(() => {
  const checkInterval = setInterval(async () => {
    const currentDate = getCurrentDate();
    const currentPlan = dailyPlanRef.current;
    if (currentPlan && currentPlan.date !== currentDate) {
      logger.log(`üîÑ Cambio de d√≠a detectado: ${currentPlan.date} ‚Üí ${currentDate}`);
      if (checkAndResetDailyPlanRef.current) {
        await checkAndResetDailyPlanRef.current();
      }
    }
  }, 30 * 1000);
  
  return () => clearInterval(checkInterval);
}, []);


/**
 * Fuerza la verificaci√≥n y reset del plan diario
 */
const forceCheckDailyReset = useCallback(async (): Promise<void> => {
  if (checkAndResetDailyPlanRef.current) {
    await checkAndResetDailyPlanRef.current();
  }
}, []);

/**
 * Resumen nutricional calculado
 */
const nutritionSummary = useMemo(() => {
  if (!dailyPlan) {
    return {
      totalCalories: 0,
      targetCalories: 1800,
      protein: { current: 0, target: 135 },
      carbs: { current: 0, target: 180 },
      fat: { current: 0, target: 60 }
    };
  }

  const consumedItems = dailyPlan.dailyMeals.reduce((acc, meal) => acc.concat(meal.items.filter(item => item.consumed)), []);
  
  const totalCalories = consumedItems.reduce((sum, item) => sum + item.calories, 0);
  const totalProtein = consumedItems.reduce((sum, item) => sum + item.protein, 0);
  const totalCarbs = consumedItems.reduce((sum, item) => sum + item.carbs, 0);
  const totalFat = consumedItems.reduce((sum, item) => sum + item.fat, 0);

  return {
    totalCalories,
    targetCalories: dailyPlan.plan.macros.calories,
    protein: { 
      current: Math.round(totalProtein), 
      target: dailyPlan.plan.macros.protein 
    },
    carbs: { 
      current: Math.round(totalCarbs), 
      target: dailyPlan.plan.macros.carbs 
    },
    fat: { 
      current: Math.round(totalFat), 
      target: dailyPlan.plan.macros.fat 
    }
  };
}, [dailyPlan]);

/**
 * Progreso de calor√≠as como porcentaje
 */
const calorieProgress = useMemo(() => {
  return (nutritionSummary.totalCalories / nutritionSummary.targetCalories) * 100;
}, [nutritionSummary]);

/**
 * Fuerza la regeneraci√≥n del plan
 */
const regeneratePlan = useCallback(async (): Promise<void> => {
  try {
    const { data: { session } } = await supabase.auth.getSession();
    if (!session) {
      throw new Error('No hay sesi√≥n activa');
    }

    if (setLoadingRef.current) {
      setLoadingRef.current(true);
    }
    setError(null);

    const response = await fetchEdge('regenerate-plan', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${session.access_token}`,
      },
    });

    if (response.ok && generateDailyPlanRef.current) {
      await generateDailyPlanRef.current(true);
    } else {
      throw new Error(`Error ${response.status}: ${await response.text()}`);
    }
  } catch (error) {
    logger.error('Error regenerating plan:', error);
    setError(error instanceof Error ? error.message : 'Error regenerando el plan');
  } finally {
    if (setLoadingRef.current) {
      setLoadingRef.current(false);
    }
  }
}, []);

/**
 * Actualiza el nivel de hidrataci√≥n
 */
const updateHydration = useCallback((glasses: number): void => {
  if (!dailyPlan) return;

  const mlPerGlass = 250;
  const consumed = glasses * mlPerGlass;

  const updatedPlan: DailyPlanData = {
    ...dailyPlan,
    hydration: {
      ...dailyPlan.hydration,
      glasses,
      consumed
    },
    lastUpdated: new Date().toISOString()
  };

  try {
    localStorage.setItem(DAILY_PLAN_KEY, JSON.stringify(updatedPlan));
    if (saveHistoricalDataRef.current) {
      saveHistoricalDataRef.current(updatedPlan);
    }
  } catch (error) {
    logger.error('Error storing hydration:', error);
  }

  if (setDailyPlanRef.current) {
    setDailyPlanRef.current(updatedPlan);
  }
}, [dailyPlan]);

/**
 * Actualiza las m√©tricas diarias
 */
const updateMetrics = useCallback((metrics: Partial<DailyPlanData['metrics']>): void => {
  if (!dailyPlan) return;

  const updatedPlan: DailyPlanData = {
    ...dailyPlan,
    metrics: {
      ...dailyPlan.metrics,
      ...metrics
    },
    lastUpdated: new Date().toISOString()
  };

  try {
    localStorage.setItem(DAILY_PLAN_KEY, JSON.stringify(updatedPlan));
    if (saveHistoricalDataRef.current) {
      saveHistoricalDataRef.current(updatedPlan);
    }
  } catch (error) {
    logger.error('Error storing metrics:', error);
  }

  if (setDailyPlanRef.current) {
    setDailyPlanRef.current(updatedPlan);
  }
}, [dailyPlan]);

/**
 * Marca/desmarca una comida como completada
 */
const toggleMealCompletion = useCallback((mealId: string, itemId: string): void => {
  if (!dailyPlan) return;

  const updatedDailyMeals = dailyPlan.dailyMeals.map(meal => {
    if (meal.id === mealId) {
      const updatedItems = meal.items.map(item => {
        if (item.id === itemId) {
          return { ...item, consumed: !item.consumed };
        }
        return item;
      });
      
      const isCompleted = updatedItems.some(item => item.consumed);
      
      return {
        ...meal,
        items: updatedItems,
        completed: isCompleted
      };
    }
    return meal;
  });

  const updatedConsumedItems = (dailyPlan.consumedItems || []).includes(itemId)
    ? (dailyPlan.consumedItems || []).filter(id => id !== itemId)
    : [...(dailyPlan.consumedItems || []), itemId];

  const updatedPlan: DailyPlanData = {
    ...dailyPlan,
    dailyMeals: updatedDailyMeals,
    consumedItems: updatedConsumedItems,
    lastUpdated: new Date().toISOString()
  };

  try {
    localStorage.setItem(DAILY_PLAN_KEY, JSON.stringify(updatedPlan));
    if (saveHistoricalDataRef.current) {
      saveHistoricalDataRef.current(updatedPlan);
    }
  } catch (error) {
    logger.error('Error storing plan:', error);
  }

  if (setDailyPlanRef.current) {
    setDailyPlanRef.current(updatedPlan);
  }

  // ‚úÖ NOTIFICACI√ìN DE COMIDA COMPLETADA
  const completedItem = updatedDailyMeals
    .find(meal => meal.id === mealId)
    ?.items.find(item => item.id === itemId);
  
  if (completedItem && completedItem.consumed) {
    showMealCompletionNotification(completedItem.name, completedItem.calories);
  }
}, [dailyPlan, showMealCompletionNotification]);

/**
 * Fuerza la regeneraci√≥n del plan nutricional desde la API
 */
const regenerateNutritionPlan = useCallback(async (): Promise<void> => {
  try {
    logger.log('üîÑ Forzando regeneraci√≥n del plan nutricional desde API...');
    
    const { data: { session } } = await supabase.auth.getSession();
    if (!session) {
      throw new Error('No hay sesi√≥n activa');
    }

    const response = await fetchEdge('regenerate-plan', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${session.access_token}`,
      },
    });

    if (response.ok) {
      logger.log('‚úÖ Plan nutricional regenerado exitosamente desde API');
      
      if (generateDailyPlanRef.current) {
        await generateDailyPlanRef.current(false);
      }
      
      return;
    } else {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(`Error regenerando plan: ${errorData.message || response.status}`);
    }
  } catch (error) {
    logger.error('‚ùå Error forzando regeneraci√≥n del plan nutricional:', error);
    throw error;
  }
}, []);

return {
  // Estado
  dailyPlan,
  loading,
  error,
  lastPlanGeneration,
  
  // Datos calculados
  mealPlan: dailyPlan?.dailyMeals || [],
  nutritionSummary,
  calorieProgress,
  
  // Acciones
  toggleMealCompletion,
  generateDailyPlan,
  regeneratePlan,
  regenerateNutritionPlan,
  updateHydration,
  updateMetrics,
  forceCheckDailyReset,
  
  // Informaci√≥n adicional
  hasNutritionPlan: !!dailyPlan?.plan,
  isCurrentDay: dailyPlan?.date === getCurrentDate(),
  planMacros: dailyPlan?.plan.macros,
  
  // Funciones hist√≥ricas
  saveHistoricalData,
  getHistoricalData,
  calculateHistoricalStats,
};
}

function restoreIcons(meals: DailyMeal[]): DailyMeal[] {
return meals.map(meal => {
  let restoredMeal = { ...meal };
  
  switch (meal.id) {
    case 'breakfast':
      restoredMeal.icon = Coffee;
      break;
    case 'morning-snack':
      restoredMeal.icon = Apple;
      break;
    case 'lunch':
      restoredMeal.icon = Utensils;
      break;
    case 'afternoon-snack':
      restoredMeal.icon = Apple;
      break;
    case 'dinner':
      restoredMeal.icon = Moon;
      break;
    default:
      if (meal.meal?.includes('Desayuno')) restoredMeal.icon = Coffee;
      else if (meal.meal?.includes('Almuerzo')) restoredMeal.icon = Utensils;
      else if (meal.meal?.includes('Cena')) restoredMeal.icon = Moon;
      else if (meal.meal?.includes('Ma√±ana') || meal.meal?.includes('Merienda')) restoredMeal.icon = Apple;
      else restoredMeal.icon = Utensils;
  }
  
  return restoredMeal;
});
}